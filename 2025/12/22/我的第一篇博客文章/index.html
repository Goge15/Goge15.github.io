<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>我的第一篇博客文章 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="概述树就是一种类似现实生活中的树的数据结构（倒置的树）。任何一颗非空树只有一个根节点。 树的定义：树是⼀种数据结构，它是由n(n≥1)个有限节点组成⼀个具有层次关系的集合。把它叫做“树”是因为它看起来像⼀棵倒挂的树，也就是说它是根朝上，⽽叶朝下的。 一棵树具有以下特点： 每个节点有零个或多个⼦节点没有⽗节点的节点称为根节点每⼀个⾮根节点有且只有⼀个⽗节点除了根节点外，每个⼦节点可以分为多个不相交的">
<meta property="og:type" content="article">
<meta property="og:title" content="我的第一篇博客文章">
<meta property="og:url" content="http://example.com/2025/12/22/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="概述树就是一种类似现实生活中的树的数据结构（倒置的树）。任何一颗非空树只有一个根节点。 树的定义：树是⼀种数据结构，它是由n(n≥1)个有限节点组成⼀个具有层次关系的集合。把它叫做“树”是因为它看起来像⼀棵倒挂的树，也就是说它是根朝上，⽽叶朝下的。 一棵树具有以下特点： 每个节点有零个或多个⼦节点没有⽗节点的节点称为根节点每⼀个⾮根节点有且只有⼀个⽗节点除了根节点外，每个⼦节点可以分为多个不相交的">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-12-21T16:32:14.000Z">
<meta property="article:modified_time" content="2025-12-21T16:36:58.494Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-我的第一篇博客文章" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/12/22/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/" class="article-date">
  <time class="dt-published" datetime="2025-12-21T16:32:14.000Z" itemprop="datePublished">2025-12-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      我的第一篇博客文章
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>概述<br>树就是一种类似现实生活中的树的数据结构（倒置的树）。任何一颗非空树只有一个根节点。</p>
<p>树的定义：树是⼀种数据结构，它是由n(n≥1)个有限节点组成⼀个具有层次关系的集合。把它叫做“树”是因为它看起来像⼀棵倒挂的树，也就是说它是根朝上，⽽叶朝下的。</p>
<p>一棵树具有以下特点：</p>
<p>每个节点有零个或多个⼦节点<br>没有⽗节点的节点称为根节点<br>每⼀个⾮根节点有且只有⼀个⽗节点<br>除了根节点外，每个⼦节点可以分为多个不相交的⼦树<br>一棵树中的任意两个结点有且仅有唯一的一条路径连通。<br>一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边。<br>一棵树不包含回路。<br>下图就是一颗树，并且是一颗二叉树。</p>
<p>如上图所示，通过上面这张图说明一下树中的常用概念：</p>
<p>节点：树中的每个元素都可以统称为节点。<br>节点的度：⼀个节点含有的⼦树的个数称为该节点的度<br>树的度：⼀棵树中，最⼤的节点度称为树的度；<br>叶节点或终端节点：度为零的节点；<br>⾮终端节点或分⽀节点：度不为零的节点；<br>根节点：顶层节点或者说没有父节点的节点。上图中 A 节点就是根节点。<br>父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点。上图中的 B 节点是 D 节点、E 节点的父节点。<br>子节点：一个节点含有的子树的根节点称为该节点的子节点。上图中 D 节点、E 节点是 B 节点的子节点。<br>兄弟节点：具有相同父节点的节点互称为兄弟节点。上图中 D 节点、E 节点的共同父节点是 B 节点，故 D 和 E 为兄弟节点。<br>叶子节点：没有子节点的节点。上图中的 D、F、H、I 都是叶子节点。<br>节点的高度：该节点到叶子节点的最长路径所包含的边数。<br>节点的深度：根节点到该节点的路径所包含的边数<br>节点的层数：节点的深度+1。<br>树的高度：根节点的高度。<br>关于树的深度和高度的定义可以看 stackoverflow 上的这个问题：What is the difference between tree depth and height? 。</p>
<p>二叉树的存储<br>二叉树的存储主要分为 链式存储 和 顺序存储 两种：</p>
<p>链式存储<br>和链表类似，二叉树的链式存储依靠指针将各个节点串联起来，不需要连续的存储空间。</p>
<p>每个节点包括三个属性：</p>
<p>数据 data。data 不一定是单一的数据，根据不同情况，可以是多个具有不同类型的数据。<br>左节点指针 left<br>右节点指针 right。<br>可是 JAVA 没有指针啊！</p>
<p>那就直接引用对象呗（别问我对象哪里找）</p>
<p>顺序存储<br>顺序存储就是利用数组进行存储，数组中的每一个位置仅存储节点的 data，不存储左右子节点的指针，子节点的索引通过数组下标完成。根结点的序号为 1，对于每个节点 Node，假设它存储在数组中下标为 i 的位置，那么它的左子节点就存储在 2i 的位置，它的右子节点存储在下标为 2i+1 的位置。</p>
<p>一棵完全二叉树的数组顺序存储如下图所示：</p>
<p>大家可以试着填写一下存储如下二叉树的数组，比较一下和完全二叉树的顺序存储有何区别：</p>
<p>可以看到，如果我们要存储的二叉树不是完全二叉树，在数组中就会出现空隙，导致内存利用率降低</p>
<p>二叉树的遍历<br>递归遍历<br>先序遍历</p>
<p>二叉树的先序遍历，就是先输出根结点，再遍历左子树，最后遍历右子树，遍历左子树和右子树的时候，同样遵循先序遍历的规则，也就是说，我们可以递归实现先序遍历。</p>
<p>代码如下：</p>
<p>java<br>public void preOrder(TreeNode root){<br>    if(root &#x3D;&#x3D; null){<br>        return;<br>    }<br>    system.out.println(root.data);<br>    preOrder(root.left);<br>    preOrder(root.right);<br>}<br>中序遍历</p>
<p>二叉树的中序遍历，就是先递归中序遍历左子树，再输出根结点的值，再递归中序遍历右子树，大家可以想象成一巴掌把树压扁，父结点被拍到了左子节点和右子节点的中间，如下图所示：</p>
<p>代码如下：</p>
<p>java<br>public void inOrder(TreeNode root){<br>    if(root &#x3D;&#x3D; null){<br>        return;<br>    }<br>    inOrder(root.left);<br>    system.out.println(root.data);<br>    inOrder(root.right);<br>}<br>后序遍历</p>
<p>二叉树的后序遍历，就是先递归后序遍历左子树，再递归后序遍历右子树，最后输出根结点的值</p>
<p>代码如下：</p>
<p>java<br>public void postOrder(TreeNode root){<br>    if(root &#x3D;&#x3D; null){<br>        return;<br>    }<br> postOrder(root.left);<br>    postOrder(root.right);<br>    system.out.println(root.data);<br>}<br>层序遍历<br>层序遍历属于迭代遍历，也比较简单</p>
<p>前序遍历<br>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p>
<p>java<br>&#x2F;&#x2F; 前序遍历顺序：中-左-右，入栈顺序：中-右-左<br>    public List<Integer> preorderTraversal(TreeNode root) {<br>        List<Integer> result &#x3D; new ArrayList&lt;&gt;();<br>        if (root &#x3D;&#x3D; null){<br>            return result;<br>        }<br>        Stack<TreeNode> stack &#x3D; new Stack&lt;&gt;();<br>        stack.push(root);<br>        while (!stack.isEmpty()){<br>            TreeNode node &#x3D; stack.pop();<br>            result.add(node.val);<br>            if (node.right !&#x3D; null){<br>                stack.push(node.right);<br>            }<br>            if (node.left !&#x3D; null){<br>                stack.push(node.left);<br>            }<br>        }<br>        return result;<br>    }<br>中序遍历<br>刚刚在进行前序遍历迭代的过程中，其实有两个操作：</p>
<p>处理：将元素放进result数组中<br>访问：遍历节点<br>前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，因为要访问的元素和要处理的元素顺序是一致的，都是中间节点，所以刚刚能写出相对简洁的代码</p>
<p>那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。</p>
<p>那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</p>
<p>java<br>&#x2F;&#x2F; 中序遍历顺序: 左-中-右 入栈顺序： 左-右<br>    public List<Integer> inorderTraversal(TreeNode root) {<br>        List<Integer> result &#x3D; new ArrayList&lt;&gt;();<br>        if (root &#x3D;&#x3D; null){<br>            return result;<br>        }<br>        Stack<TreeNode> stack &#x3D; new Stack&lt;&gt;();<br>        TreeNode cur &#x3D; root;<br>        while (cur !&#x3D; null || !stack.isEmpty()){<br>           if (cur !&#x3D; null){<br>               stack.push(cur);<br>               cur &#x3D; cur.left;<br>           }else{<br>               cur &#x3D; stack.pop();<br>               result.add(cur.val);<br>               cur &#x3D; cur.right;<br>           }<br>        }<br>        return result;<br>    }<br>后序遍历<br>后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了</p>
<p>java<br>&#x2F;&#x2F; 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果<br>    public List<Integer> postorderTraversal(TreeNode root) {<br>        List<Integer> result &#x3D; new ArrayList&lt;&gt;();<br>        if (root &#x3D;&#x3D; null){<br>            return result;<br>        }<br>        Stack<TreeNode> stack &#x3D; new Stack&lt;&gt;();<br>        stack.push(root);<br>        while (!stack.isEmpty()){<br>            TreeNode node &#x3D; stack.pop();<br>            result.add(node.val);<br>            if (node.left !&#x3D; null){<br>                stack.push(node.left);<br>            }<br>            if (node.right !&#x3D; null){<br>                stack.push(node.right);<br>            }<br>        }<br>        Collections.reverse(result);<br>        return result;<br>    }<br>二叉树的分类</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/12/22/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/" data-id="cmjfzf5ie0001jsst21pi0asv" data-title="我的第一篇博客文章" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2025/12/22/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/12/">December 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/12/22/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/">我的第一篇博客文章</a>
          </li>
        
          <li>
            <a href="/2025/12/22/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>